{
  "parsedContent": {
    "content": "# Developer Guidelines\n\n**Project**: folder-mcp  \n**Last Updated**: June 12, 2025  \n**Purpose**: Establish coding standards and module boundary guidelines for maintainable, scalable architecture\n\n## ğŸš€ Quick Start for New Developers\n\n### Prerequisites Checklist\n\nBefore you start coding, ensure you have:\n\n- [ ] **Node.js 18+** installed\n- [ ] **TypeScript** knowledge (basics: types, interfaces, generics)\n- [ ] **Git** configured with your credentials\n- [ ] **VS Code** with recommended extensions installed\n- [ ] **Understanding of Promises/async-await** in JavaScript\n\n### First Day Setup\n\n1. **Clone and Setup**:\n   ```powershell\n   git clone <repository-url>\n   cd folder-mcp\n   npm install\n   npm run build\n   npm test\n   ```\n\n2. **Understand the Project**:\n   - Read `README.md` for project overview\n   - Review `CONFIGURATION.md` for setup options\n   - Run `npm run cli -- --help` to see available commands\n\n3. **Explore the Codebase**:\n   - Start with `src/interfaces/` to understand entry points\n   - Look at `src/domain/` to understand business logic\n   - Check `tests/` to see how features are tested\n\n> **Why this order matters**: Starting with interfaces helps you understand what the system does for users, then diving into domain logic shows you how it works internally. This top-down approach prevents getting lost in implementation details.\n\n## ğŸ—ï¸ Architecture Overview\n\nThe folder-mcp project follows a **layered architecture** pattern with strict module boundaries to ensure separation of concerns, testability, and maintainability.\n\n> **Why layered architecture?** It prevents code from becoming a \"big ball of mud\" where everything depends on everything else. This makes the code easier to understand, test, and modify. Think of it like organizing a house - you don't put the kitchen in the bathroom!\n\n### Layered Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             INTERFACES                  â”‚ â† Entry points (CLI, MCP, API)\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚            APPLICATION                  â”‚ â† Use cases & workflows\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚              DOMAIN                     â”‚ â† Business logic\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚          INFRASTRUCTURE                 â”‚ â† Technical services\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚              SHARED                     â”‚ â† Common utilities & DI\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## ğŸ“ Module Structure\n\n### Directory Organization\n\n```\nsrc/\nâ”œâ”€â”€ interfaces/                 # External interfaces (Entry points)\nâ”‚   â”œâ”€â”€ cli/                   # Command-line interface\nâ”‚   â”œâ”€â”€ mcp/                   # MCP protocol interface\nâ”‚   â””â”€â”€ api/                   # Future REST API\nâ”‚\nâ”œâ”€â”€ application/               # Use cases & business workflows\nâ”‚   â”œâ”€â”€ indexing/             # Indexing orchestration\nâ”‚   â”œâ”€â”€ serving/              # Content serving workflows\nâ”‚   â””â”€â”€ monitoring/           # Watch & monitoring workflows\nâ”‚\nâ”œâ”€â”€ domain/                   # Core business logic\nâ”‚   â”œâ”€â”€ files/               # File system domain\nâ”‚   â”œâ”€â”€ content/             # Content processing domain\nâ”‚   â”œâ”€â”€ embeddings/          # AI/ML domain\nâ”‚   â””â”€â”€ search/              # Search domain\nâ”‚\nâ”œâ”€â”€ infrastructure/          # Technical infrastructure\nâ”‚   â”œâ”€â”€ cache/              # Caching infrastructure\nâ”‚   â”œâ”€â”€ config/             # Configuration infrastructure\nâ”‚   â”œâ”€â”€ logging/            # Logging infrastructure\nâ”‚   â””â”€â”€ errors/             # Error handling infrastructure\nâ”‚\nâ””â”€â”€ shared/                 # Shared foundation\n    â”œâ”€â”€ types/              # Shared type definitions\n    â”œâ”€â”€ utils/              # Shared utilities\n    â””â”€â”€ di/                 # Dependency injection\n```\n\n### Layer Responsibilities\n\n#### ğŸ”Œ **Interfaces Layer** (`src/interfaces/`)\n- **Purpose**: External communication protocols and entry points\n- **Responsibilities**:\n  - Handle user input (CLI commands, MCP requests, API calls)\n  - Transform external requests to internal use cases\n  - Format responses for external consumption\n  - Validate input parameters\n- **Characteristics**: Thin layer that delegates to application services\n\n#### ğŸ¯ **Application Layer** (`src/application/`)\n- **Purpose**: Use case orchestration and business workflows\n- **Responsibilities**:\n  - Coordinate multiple domain services\n  - Implement business workflows\n  - Handle cross-cutting concerns (transactions, logging)\n  - Orchestrate complex operations\n- **Characteristics**: Stateless coordinators\n\n#### ğŸ§  **Domain Layer** (`src/domain/`)\n- **Purpose**: Core business logic and rules\n- **Responsibilities**:\n  - Implement business rules and logic\n  - Define domain entities and value objects\n  - Contain domain-specific algorithms\n  - Enforce business invariants\n- **Characteristics**: Pure business logic, no external dependencies\n\n#### ğŸ”§ **Infrastructure Layer** (`src/infrastructure/`)\n- **Purpose**: Technical implementation details\n- **Responsibilities**:\n  - Database access and caching\n  - External service integration\n  - File system operations\n  - Logging and monitoring\n- **Characteristics**: Technical services with external dependencies\n\n#### ğŸ“š **Shared Layer** (`src/shared/`)\n- **Purpose**: Common utilities and foundational services\n- **Responsibilities**:\n  - Type definitions\n  - Utility functions\n  - Dependency injection setup\n  - Constants and enums\n- **Characteristics**: No business logic, used by all layers\n\n## ğŸš§ Module Boundaries & Dependency Rules\n\n### âœ… Allowed Dependencies\n\n| Layer | Can Import From | Rationale |\n|-------|----------------|-----------|\n| `interfaces/` | `application/`, `shared/` | Entry points orchestrate use cases |\n| `application/` | `domain/`, `shared/` | Use cases coordinate domain logic |\n| `domain/` | `shared/` only | Business logic is pure, no external deps |\n| `infrastructure/` | `shared/` only | Technical services use shared utilities |\n| `shared/` | Internal only | Foundation layer has no external deps |\n\n### âŒ Forbidden Dependencies\n\n- **Domain Isolation**: `domain/` cannot import from `infrastructure/` or `application/`\n- **Infrastructure Isolation**: `infrastructure/` cannot import from `domain/` or `application/`\n- **Application Boundaries**: `application/` cannot import from `infrastructure/` (except via DI)\n- **Shared Foundation**: `shared/` cannot import from any other layer\n- **No Circular Dependencies**: No circular dependencies between any modules\n\n> **Why these restrictions matter**: \n> - **Domain Isolation**: Keeps business logic pure and testable without external dependencies\n> - **Infrastructure Isolation**: Prevents technical details from leaking into business logic\n> - **Application Boundaries**: Ensures use cases remain focused on orchestration, not implementation\n> - **Shared Foundation**: Prevents the foundation from becoming dependent on higher-level concerns\n> - **No Circular Dependencies**: Prevents infinite loops during module loading and makes the code easier to understand\n\n### ğŸ”„ Communication Patterns\n\n#### âœ… Correct Patterns\n\n```typescript\n// âœ… Interface â†’ Application â†’ Domain\n// interfaces/cli/commands/serve.ts\nimport { ServingOrchestrator } from '../../../application/serving/index.js';\n\n// âœ… Application â†’ Domain\n// application/serving/orchestrator.ts\nimport { FileParser } from '../../domain/files/index.js';\nimport { VectorSearch } from '../../domain/search/index.js';\n\n// âœ… Domain â†” Infrastructure via Dependency Injection\n// domain/files/parser.ts\nconstructor(\n  private readonly cacheService: ICacheService,  // Injected\n  private readonly loggingService: ILoggingService  // Injected\n) {}\n```\n\n#### âŒ Anti-Patterns\n\n```typescript\n// âŒ Wrong: Direct infrastructure import in domain\nimport { CacheService } from '../../infrastructure/cache/storage.js';\n\n// âŒ Wrong: Domain importing from application\nimport { IndexingOrchestrator } from '../../application/indexing/orchestrator.js';\n\n// âŒ Wrong: Multiple layer jumps\nimport { FileParser } from '../../../domain/files/parser.js';\n```\n\n## ğŸ“ Coding Standards\n\n### 1. Public API Design\n\nEvery module must expose a clean public API through its `index.ts` file:\n\n```typescript\n// src/domain/files/index.ts\nexport { FileParser } from './parser.js';\nexport { FileWatcher } from './watcher.js';\nexport { createFileFingerprint } from './fingerprint.js';\nexport type { \n  FileOperations, \n  ParsedFile, \n  FileMetadata \n} from './types.js';\n\n// Internal implementation details are not exported\n```\n\n### 2. Interface Segregation\n\nDefine focused, specific interfaces rather than large monolithic ones:\n\n```typescript\n// âœ… Good: Focused interface\nexport interface FileOperations {\n  scanFolder(path: string): Promise<string[]>;\n  parseFile(path: string): Promise<ParsedContent>;\n  watchFolder(path: string, callback: FileChangeCallback): Promise<void>;\n}\n\n// âŒ Bad: Monolithic interface\nexport interface FileSystemService {\n  scanFolder(path: string): Promise<string[]>;\n  parseFile(path: string): Promise<ParsedContent>;\n  watchFolder(path: string, callback: FileChangeCallback): Promise<void>;\n  cacheFile(path: string): Promise<void>;\n  logActivity(message: string): void;\n  sendNotification(event: FileEvent): Promise<void>;\n}\n```\n\n### 3. Dependency Injection\n\nUse constructor injection for all dependencies:\n\n> **Why constructor injection?** It makes dependencies explicit and required, prevents hidden dependencies, makes testing easier (you can inject mocks), and follows the \"fail fast\" principle - if a dependency is missing, the object can't be created.\n\n```typescript\n// âœ… Good: Constructor injection\nexport class IndexingOrchestrator {\n  constructor(\n    private readonly fileParser: FileParser,\n    private readonly contentChunker: ContentChunker,\n    private readonly embeddingModel: EmbeddingModel,\n    private readonly cache: ICacheService\n  ) {}\n  \n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    // Implementation uses injected dependencies\n    // Easy to test because dependencies can be mocked\n  }\n}\n\n// âŒ Bad: Direct instantiation\nexport class IndexingOrchestrator {\n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    const fileParser = new FileParser(); // Tight coupling - hard to change\n    const cache = new CacheService(); // Hard to test - always uses real cache\n    // What if FileParser needs dependencies? This approach doesn't scale.\n  }\n}\n```\n\n### 4. Error Handling\n\nImplement consistent error handling patterns:\n\n> **Why consistent error handling matters**: It makes debugging easier, provides better user experience, prevents crashes, and helps maintain system stability. Different layers should handle errors differently based on their responsibilities.\n\n```typescript\n// Domain layer: Throw domain-specific errors\n// Why: Domain errors represent business rule violations\nexport class ContentChunker {\n  chunkText(text: string): TextChunk[] {\n    if (!text.trim()) {\n      throw new EmptyContentError('Cannot chunk empty content');\n    }\n    // Implementation\n  }\n}\n\n// Application layer: Handle and transform errors\n// Why: Application layer knows how to recover from different error types\nexport class IndexingOrchestrator {\n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    try {\n      // Implementation\n    } catch (error) {\n      if (error instanceof EmptyContentError) {\n        // Graceful handling: log warning but continue processing\n        this.logger.warn(`Skipping empty file: ${error.message}`);\n        return { success: true, warnings: [error.message] };\n      }\n      // Unknown errors are wrapped and re-thrown\n      throw new IndexingError(`Failed to index folder: ${error.message}`, error);\n    }\n  }\n}\n\n// Interface layer: Convert errors to user-friendly messages\n// Why: Users shouldn't see technical error details\nexport class CLICommand {\n  async execute(): Promise<void> {\n    try {\n      await this.orchestrator.indexFolder(path);\n      console.log('âœ… Indexing completed successfully');\n    } catch (error) {\n      if (error instanceof IndexingError) {\n        console.error(`âŒ Failed to index folder: ${error.userMessage}`);\n        process.exit(1);\n      }\n      throw error; // Re-throw unexpected errors\n    }\n  }\n}\n```\n\n### 5. Type Safety\n\nUse TypeScript effectively for type safety:\n\n> **Why strong typing matters**: TypeScript catches errors at compile time instead of runtime, makes code self-documenting, improves IDE support with autocomplete and refactoring, and makes large codebases maintainable. Weak typing leads to runtime errors and confusion about what data structures contain.\n\n```typescript\n// âœ… Good: Strong typing\nexport interface IndexingOptions {\n  readonly chunkSize: number;        // Clear: this is a number\n  readonly overlapSize: number;      // Clear: this is a number  \n  readonly fileTypes: readonly string[];     // Clear: array of strings, immutable\n  readonly excludePatterns: readonly string[]; // Clear: array of strings, immutable\n}\n\nexport interface IndexingResult {\n  readonly success: boolean;         // Clear: boolean result\n  readonly filesProcessed: number;   // Clear: count of files\n  readonly warnings: readonly string[];     // Clear: array of warning messages\n  readonly errors: readonly Error[]; // Clear: array of error objects\n}\n\n// âŒ Bad: Weak typing\nexport interface IndexingOptions {\n  [key: string]: any; // Could be anything! No IDE help, no compile-time checks\n}\n\n// âŒ Also bad: Mutable types\nexport interface IndexingResult {\n  success: boolean;\n  warnings: string[]; // Can be modified after creation, leading to bugs\n}\n```\n\n**Additional Type Safety Best Practices**:\n\n```typescript\n// âœ… Use union types for constrained values\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n// Prevents typos: logLevel = 'information' would be a compile error\n\n// âœ… Use branded types for IDs\ntype UserId = string & { readonly brand: unique symbol };\ntype PostId = string & { readonly brand: unique symbol };\n// Prevents mixing up different ID types\n\n// âœ… Use optional vs required properties intentionally\ninterface CreateUserRequest {\n  name: string;           // Required\n  email: string;         // Required\n  avatar?: string;       // Optional\n}\n```\n\n## ğŸ”„ Git Workflow & Collaboration\n\n### Branch Strategy\n\n> **Why we use feature branches**: They allow multiple developers to work on different features simultaneously without conflicts, enable code review before merging, and provide a clear history of what changes were made for each feature.\n\n```bash\n# Create a new feature branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/add-search-ranking\n\n# Work on your feature with meaningful commits\ngit add .\ngit commit -m \"Add vector similarity scoring algorithm\"\ngit commit -m \"Implement search result ranking logic\"\ngit commit -m \"Add tests for ranking functionality\"\n\n# Push and create pull request\ngit push origin feature/add-search-ranking\n```\n\n### Commit Message Guidelines\n\n> **Why good commit messages matter**: They help other developers (and future you) understand why changes were made, make debugging easier when using `git blame`, and create a clear history of the project's evolution.\n\n**Format**: `<type>(<scope>): <description>`\n\n```bash\n# âœ… Good commit messages\nfeat(search): add semantic similarity ranking\nfix(cli): handle empty input files gracefully  \nrefactor(domain): extract chunking strategy interface\ntest(search): add integration tests for vector search\ndocs(api): update MCP protocol documentation\n\n# âŒ Bad commit messages\nfix stuff\nupdate code\nworking version\nasdf\n```\n\n**Types**:\n- `feat`: New feature\n- `fix`: Bug fix\n- `refactor`: Code restructuring without changing behavior\n- `test`: Adding or updating tests\n- `docs`: Documentation changes\n- `chore`: Build process or auxiliary tool changes\n\n### Code Review Guidelines\n\n> **Why code reviews are essential**: They catch bugs early, share knowledge across the team, ensure code follows our standards, and improve overall code quality. Even senior developers benefit from fresh eyes on their code.\n\n**As a Reviewer**:\n- Focus on logic, architecture, and maintainability\n- Be constructive: suggest solutions, not just problems\n- Ask questions if something is unclear\n- Approve when the code meets our standards\n\n**As an Author**:\n- Keep PRs small and focused (< 400 lines when possible)\n- Write clear PR descriptions explaining what and why\n- Respond to feedback promptly and professionally\n- Don't take feedback personally - it's about the code, not you\n\n```markdown\n# Good PR Description Template\n## What\nBrief description of the changes\n\n## Why  \nExplanation of the problem this solves\n\n## Testing\nHow you tested the changes\n\n## Notes\nAny special considerations for reviewers\n```\n\n## ğŸ§ª Testing Guidelines\n\n> **Why testing is crucial**: Tests catch bugs before users do, enable safe refactoring, document how code should behave, and give confidence when making changes. Without tests, every change is scary because you don't know what might break.\n\n### Testing Pyramid\n\n```\n        /\\\n       /  \\\n      / E2E \\ <- Few, slow, expensive but realistic\n     /______\\\n    /        \\\n   /Integration\\ <- Some, medium speed, test component interaction  \n  /__________\\\n /            \\\n/     Unit      \\ <- Many, fast, cheap, test individual functions\n/______________\\\n```\n\n**Why this distribution?**\n- **Unit tests**: Fast feedback, pinpoint failures, easy to write\n- **Integration tests**: Catch interface problems, test real interactions\n- **E2E tests**: Ensure the whole system works, catch UI/UX issues\n\n### 1. Test Structure\n\nOrganize tests to mirror the module structure:\n\n```\ntests/\nâ”œâ”€â”€ unit/\nâ”‚   â”œâ”€â”€ domain/\nâ”‚   â”‚   â”œâ”€â”€ files/\nâ”‚   â”‚   â”œâ”€â”€ content/\nâ”‚   â”‚   â””â”€â”€ search/\nâ”‚   â”œâ”€â”€ application/\nâ”‚   â””â”€â”€ infrastructure/\nâ”œâ”€â”€ integration/\nâ”œâ”€â”€ architectural/\nâ””â”€â”€ e2e/\n```\n\n### 2. Domain Testing\n\nDomain logic should be easily testable in isolation:\n\n> **Why domain tests are important**: Domain logic contains your business rules - the core value of your application. These tests should be fast, reliable, and test pure logic without external dependencies.\n\n```typescript\n// âœ… Good: Pure domain logic test\ndescribe('ContentChunker', () => {\n  it('should chunk text into specified sizes', () => {\n    // Arrange: Set up test data\n    const chunker = new ContentChunker({ chunkSize: 100, overlapSize: 20 });\n    const longText = 'A'.repeat(250); // 250 characters\n    \n    // Act: Execute the functionality\n    const result = chunker.chunkText(longText);\n    \n    // Assert: Verify the results\n    expect(result).toHaveLength(3); // Should create 3 chunks\n    expect(result[0].text).toHaveLength(100);\n    expect(result[1].text).toHaveLength(100);\n    expect(result[2].text).toHaveLength(70); // Remaining text\n    \n    // Verify overlap\n    const overlap1to2 = result[0].text.slice(-20);\n    const start2 = result[1].text.slice(0, 20);\n    expect(overlap1to2).toBe(start2);\n  });\n  \n  it('should handle edge cases gracefully', () => {\n    const chunker = new ContentChunker({ chunkSize: 100, overlapSize: 20 });\n    \n    // Test empty input\n    expect(() => chunker.chunkText('')).toThrow(EmptyContentError);\n    \n    // Test text shorter than chunk size\n    const shortText = 'Short text';\n    const result = chunker.chunkText(shortText);\n    expect(result).toHaveLength(1);\n    expect(result[0].text).toBe(shortText);\n  });\n});\n```\n\n### 3. Application Testing\n\nApplication layer tests should use mocks for dependencies:\n\n```typescript\n// âœ… Good: Application test with mocks\ndescribe('IndexingOrchestrator', () => {\n  it('should orchestrate complete indexing workflow', async () => {\n    const mockFileParser = createMockFileParser();\n    const mockContentChunker = createMockContentChunker();\n    const mockEmbeddingModel = createMockEmbeddingModel();\n    const mockCache = createMockCache();\n    \n    const orchestrator = new IndexingOrchestrator(\n      mockFileParser,\n      mockContentChunker,\n      mockEmbeddingModel,\n      mockCache\n    );\n    \n    const result = await orchestrator.indexFolder('/test/path');\n    \n    expect(result.success).toBe(true);\n    expect(mockFileParser.scanFolder).toHaveBeenCalledWith('/test/path');\n    expect(mockCache.storeEmbeddings).toHaveBeenCalled();\n  });\n});\n```\n\n### 4. Architectural Tests\n\nEnforce architectural boundaries with automated tests:\n\n```typescript\n// tests/architectural/boundaries.test.ts\ndescribe('Module Boundaries', () => {\n  it('should not allow domain to import from infrastructure', () => {\n    const domainFiles = glob.sync('src/domain/**/*.ts');\n    domainFiles.forEach(file => {\n      const content = fs.readFileSync(file, 'utf8');\n      expect(content).not.toMatch(/from ['\"]\\.\\.\\/.+\\/infrastructure/);\n      expect(content).not.toMatch(/import.*infrastructure/);\n    });\n  });\n  \n  it('should not allow circular dependencies', () => {\n    const dependencyGraph = buildDependencyGraph('src/');\n    const cycles = findCycles(dependencyGraph);\n    expect(cycles).toHaveLength(0);\n  });\n});\n```\n\n## ğŸš€ Development Workflow\n\n### 1. Adding New Features\n\nWhen adding new functionality, follow this approach:\n\n1. **Identify the Domain**: Which domain does this feature belong to?\n2. **Design Domain Logic**: Implement pure business logic in the domain layer\n3. **Create Application Workflow**: Orchestrate domain services in application layer\n4. **Add Interface**: Expose functionality through appropriate interface\n5. **Update DI Configuration**: Register new services in dependency injection container\n6. **Write Tests**: Add tests at each layer\n7. **Update Documentation**: Update relevant documentation\n\n### 2. File Organization\n\n#### Module Index Files\n\nEach module should have a well-defined public API:\n\n```typescript\n// src/domain/content/index.ts\n// Public API - what other modules can use\nexport { ContentProcessor } from './processing.js';\nexport { ContentChunker } from './chunking.js';\nexport { extractMetadata } from './metadata.js';\n\n// Type exports\nexport type { \n  ContentOperations,\n  TextChunk,\n  ProcessedContent,\n  ChunkingOptions,\n  ContentMetadata \n} from './types.js';\n\n// Internal implementation details are NOT exported\n// - helpers.ts\n// - validators.ts\n// - constants.ts\n```\n\n#### Internal Organization\n\nWithin each module, organize files by responsibility:\n\n```\nsrc/domain/content/\nâ”œâ”€â”€ index.ts           # Public API\nâ”œâ”€â”€ types.ts           # Type definitions\nâ”œâ”€â”€ processing.ts      # Main business logic\nâ”œâ”€â”€ chunking.ts        # Chunking algorithms\nâ”œâ”€â”€ metadata.ts        # Metadata extraction\nâ”œâ”€â”€ helpers.ts         # Internal utilities (not exported)\nâ”œâ”€â”€ validators.ts      # Internal validation (not exported)\nâ””â”€â”€ constants.ts       # Internal constants (not exported)\n```\n\n### 3. Import Guidelines\n\n#### Use Absolute Imports from Module Root\n\n```typescript\n// âœ… Good: Import from module public API\nimport { ContentProcessor } from '../../domain/content/index.js';\nimport { IndexingOrchestrator } from '../../application/indexing/index.js';\n\n// âŒ Bad: Direct imports from internal files\nimport { ContentProcessor } from '../../domain/content/processing.js';\nimport { chunkText } from '../../domain/content/chunking.js';\n```\n\n#### Organize Imports\n\n```typescript\n// 1. Node.js built-in modules\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\n// 2. External packages\nimport { EventEmitter } from 'events';\nimport chokidar from 'chokidar';\n\n// 3. Internal modules (same layer)\nimport { FileOperations } from './interfaces.js';\nimport { createFileFingerprint } from './fingerprint.js';\n\n// 4. Shared modules\nimport { ILoggingService } from '../../shared/di/interfaces.js';\nimport { validatePath } from '../../shared/utils/index.js';\n\n// 5. Types (separate section)\nimport type { \n  ParsedContent, \n  FileMetadata, \n  FileChangeCallback \n} from './types.js';\n```\n\n## ğŸ” Code Quality Standards\n\n### 1. Naming Conventions\n\n- **Classes**: PascalCase (`FileParser`, `IndexingOrchestrator`)\n- **Interfaces**: PascalCase with 'I' prefix for service interfaces (`ILoggingService`)\n- **Methods**: camelCase (`parseFile`, `generateEmbeddings`)\n- **Constants**: SCREAMING_SNAKE_CASE (`MAX_CHUNK_SIZE`, `DEFAULT_TIMEOUT`)\n- **Files**: kebab-case (`content-processor.ts`, `file-operations.ts`)\n\n### 2. Documentation\n\n#### Class Documentation\n\n```typescript\n/**\n * Processes file content into structured, searchable chunks.\n * \n * This class implements various chunking strategies to break down\n * large documents into smaller, semantically meaningful pieces\n * that can be efficiently processed by embedding models.\n * \n * @example\n * ```typescript\n * const chunker = new ContentChunker({ \n *   chunkSize: 1000, \n *   overlapSize: 200 \n * });\n * const chunks = chunker.chunkText(documentText);\n * ```\n */\nexport class ContentChunker {\n  /**\n   * Creates a new ContentChunker with the specified options.\n   * \n   * @param options - Configuration for chunking behavior\n   * @param logger - Optional logging service for debugging\n   */\n  constructor(\n    private readonly options: ChunkingOptions,\n    private readonly logger?: ILoggingService\n  ) {}\n}\n```\n\n#### Method Documentation\n\n```typescript\n/**\n * Chunks text content into overlapping segments.\n * \n * @param text - The input text to be chunked\n * @param options - Optional chunking options to override defaults\n * @returns Array of text chunks with metadata\n * @throws {EmptyContentError} When input text is empty or whitespace only\n * @throws {InvalidChunkSizeError} When chunk size is invalid\n */\nchunkText(text: string, options?: Partial<ChunkingOptions>): TextChunk[] {\n  // Implementation\n}\n```\n\n### 3. Performance Considerations\n\n#### Async/Await Best Practices\n\n```typescript\n// âœ… Good: Parallel operations where possible\nexport class IndexingOrchestrator {\n  async indexFiles(filePaths: string[]): Promise<IndexingResult> {\n    // Parse files in parallel\n    const parsePromises = filePaths.map(path => this.fileParser.parseFile(path));\n    const parsedFiles = await Promise.all(parsePromises);\n    \n    // Process chunks sequentially to control memory usage\n    const allChunks: TextChunk[] = [];\n    for (const file of parsedFiles) {\n      const chunks = await this.contentChunker.chunkContent(file.content);\n      allChunks.push(...chunks);\n    }\n    \n    return { success: true, filesProcessed: filePaths.length };\n  }\n}\n\n// âŒ Bad: Sequential operations when parallel is possible\nexport class IndexingOrchestrator {\n  async indexFiles(filePaths: string[]): Promise<IndexingResult> {\n    const allChunks: TextChunk[] = [];\n    \n    // Unnecessarily sequential\n    for (const path of filePaths) {\n      const file = await this.fileParser.parseFile(path);\n      const chunks = await this.contentChunker.chunkContent(file.content);\n      allChunks.push(...chunks);\n    }\n    \n    return { success: true, filesProcessed: filePaths.length };\n  }\n}\n```\n\n#### Memory Management\n\n```typescript\n// âœ… Good: Process large datasets in batches\nexport class EmbeddingGenerator {\n  async generateEmbeddings(chunks: TextChunk[]): Promise<EmbeddingVector[]> {\n    const batchSize = this.options.batchSize;\n    const results: EmbeddingVector[] = [];\n    \n    for (let i = 0; i < chunks.length; i += batchSize) {\n      const batch = chunks.slice(i, i + batchSize);\n      const batchResults = await this.processEmbeddingBatch(batch);\n      results.push(...batchResults);\n      \n      // Allow garbage collection between batches\n      if (i % (batchSize * 10) === 0) {\n        await this.yield();\n      }\n    }\n    \n    return results;\n  }\n  \n  private async yield(): Promise<void> {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n}\n```\n\n## ğŸš¨ Common Anti-Patterns to Avoid\n\n### 1. Layer Violations\n\n```typescript\n// âŒ Bad: Domain layer directly using infrastructure\nexport class FileParser {\n  async parseFile(path: string): Promise<ParsedContent> {\n    // Wrong: Direct infrastructure dependency\n    const cache = new CacheService();\n    const cached = await cache.get(path);\n    if (cached) return cached;\n    \n    // Parse file...\n  }\n}\n\n// âœ… Good: Domain layer using injected abstraction\nexport class FileParser {\n  constructor(\n    private readonly cache: ICacheService\n  ) {}\n  \n  async parseFile(path: string): Promise<ParsedContent> {\n    const cached = await this.cache.get(path);\n    if (cached) return cached;\n    \n    // Parse file...\n  }\n}\n```\n\n### 2. God Objects\n\n```typescript\n// âŒ Bad: Single class doing too much\nexport class FileSystemManager {\n  parseFile(path: string): ParsedContent { /* */ }\n  chunkContent(content: string): TextChunk[] { /* */ }\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n  searchSimilar(query: string): SearchResult[] { /* */ }\n  cacheResults(results: any): void { /* */ }\n  logActivity(message: string): void { /* */ }\n}\n\n// âœ… Good: Single responsibility principle\nexport class FileParser {\n  parseFile(path: string): ParsedContent { /* */ }\n}\n\nexport class ContentChunker {\n  chunkContent(content: string): TextChunk[] { /* */ }\n}\n\nexport class EmbeddingGenerator {\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n}\n```\n\n### 3. Leaky Abstractions\n\n```typescript\n// âŒ Bad: Exposing implementation details\nexport interface FileOperations {\n  parseFile(path: string): Promise<ParsedContent>;\n  getCache(): CacheService; // Leaky abstraction\n  getLogger(): Logger; // Leaky abstraction\n}\n\n// âœ… Good: Clean abstraction\nexport interface FileOperations {\n  parseFile(path: string): Promise<ParsedContent>;\n  clearCache(): Promise<void>; // Behavior, not implementation\n}\n```\n\n## ğŸ“š Resources\n\n### Learning Materials\n\n- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)\n- [Dependency Injection Patterns](https://martinfowler.com/articles/injection.html)\n\n### Tools\n\n- **ESLint**: For code quality and style enforcement\n- **Prettier**: For consistent code formatting\n- **TypeScript**: For type safety and better developer experience\n- **Vitest**: For fast, reliable testing\n- **madge**: For dependency analysis and circular dependency detection\n\n### IDE Configuration\n\n#### VS Code Settings\n\n```json\n{\n  \"typescript.preferences.includePackageJsonAutoImports\": \"off\",\n  \"typescript.suggest.autoImports\": true,\n  \"typescript.preferences.importModuleSpecifier\": \"relative\",\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n```\n\n## ğŸš¨ Debugging & Troubleshooting\n\n### Common Issues for New Developers\n\n> **Why debugging skills matter**: You'll spend more time debugging than writing new code. Learning systematic debugging approaches saves hours of frustration and makes you more effective.\n\n#### Issue 1: Import/Module Not Found Errors\n\n```typescript\n// âŒ Error: Cannot find module '../../../domain/files'\nimport { FileParser } from '../../../domain/files';\n\n// âœ… Fix: Use proper file extensions in Node.js\nimport { FileParser } from '../../../domain/files/index.js';\n\n// âœ… Better: Import from module public API\nimport { FileParser } from '../../../domain/files/index.js';\n```\n\n**Debugging steps**:\n1. Check if the file exists at the path you're importing\n2. Verify the file has the correct export\n3. Ensure you're using `.js` extensions for local imports\n4. Check if there's a public API (index.ts) you should import from instead\n\n#### Issue 2: Circular Dependency Errors\n\n```bash\n# Error message you might see:\nReferenceError: Cannot access 'FileParser' before initialization\n```\n\n**How to fix**:\n1. Use the architectural tests to detect cycles: `npm run test:arch`\n2. Identify the cycle using dependency analysis\n3. Break the cycle by:\n   - Moving shared code to a lower layer\n   - Using dependency injection instead of direct imports\n   - Creating an interface in the shared layer\n\n#### Issue 3: Type Errors After Refactoring\n\n```typescript\n// Error: Property 'chunkText' does not exist on type 'ContentProcessor'\nconst chunks = processor.chunkText(content);\n```\n\n**Debugging approach**:\n1. Check what type `processor` actually is (hover in VS Code)\n2. Look at the interface/class definition\n3. Check if the method was renamed or moved\n4. Update the import if the API changed\n\n### Debugging Strategies\n\n#### 1. Console Debugging (Quick & Simple)\n\n```typescript\nexport class IndexingOrchestrator {\n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    console.log('ğŸ” Starting indexing for:', folderPath);\n    \n    const files = await this.fileParser.scanFolder(folderPath);\n    console.log('ğŸ“ Found files:', files.length);\n    \n    for (const file of files) {\n      console.log('ğŸ“„ Processing:', file);\n      const content = await this.fileParser.parseFile(file);\n      console.log('ğŸ“ Content length:', content.text.length);\n      // ... more processing\n    }\n  }\n}\n```\n\n#### 2. Using the Debugger (VS Code)\n\n1. Set breakpoints by clicking the left margin in VS Code\n2. Run with debugger: `F5` or `Debug > Start Debugging`\n3. Step through code: `F10` (step over), `F11` (step into)\n4. Inspect variables in the Debug panel\n\n#### 3. Logging for Production\n\n```typescript\nexport class IndexingOrchestrator {\n  constructor(\n    private readonly logger: ILoggingService\n  ) {}\n  \n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    this.logger.info('Starting indexing', { folderPath });\n    \n    try {\n      const result = await this.processFolder(folderPath);\n      this.logger.info('Indexing completed', { \n        folderPath, \n        filesProcessed: result.filesProcessed \n      });\n      return result;\n    } catch (error) {\n      this.logger.error('Indexing failed', { folderPath, error });\n      throw error;\n    }\n  }\n}\n```\n\n## ğŸ”’ Security Guidelines\n\n> **Why security matters**: Even internal tools can be attacked or misused. Security vulnerabilities can lead to data breaches, system compromise, or service disruption. Better to build security in from the start than add it later.\n\n### Input Validation\n\n```typescript\n// âœ… Good: Validate all inputs\nexport class FileParser {\n  async parseFile(filePath: string): Promise<ParsedContent> {\n    // Validate input\n    if (!filePath || typeof filePath !== 'string') {\n      throw new ValidationError('File path must be a non-empty string');\n    }\n    \n    // Prevent path traversal attacks\n    const normalizedPath = path.normalize(filePath);\n    if (normalizedPath.includes('..')) {\n      throw new SecurityError('Path traversal not allowed');\n    }\n    \n    // Check file exists and is readable\n    await fs.access(normalizedPath, fs.constants.R_OK);\n    \n    // Proceed with parsing...\n  }\n}\n\n// âŒ Bad: No validation\nexport class FileParser {\n  async parseFile(filePath: string): Promise<ParsedContent> {\n    // Directly using user input - dangerous!\n    const content = await fs.readFile(filePath, 'utf8');\n    return { text: content };\n  }\n}\n```\n\n### Error Information Disclosure\n\n```typescript\n// âœ… Good: Generic error messages for users\nexport class CLICommand {\n  async execute(filePath: string): Promise<void> {\n    try {\n      await this.processor.processFile(filePath);\n    } catch (error) {\n      // Log full error details for developers\n      this.logger.error('File processing failed', { filePath, error });\n      \n      // Show generic message to users\n      console.error('Failed to process file. Please check the file path and permissions.');\n      process.exit(1);\n    }\n  }\n}\n\n// âŒ Bad: Exposing internal details\nexport class CLICommand {\n  async execute(filePath: string): Promise<void> {\n    try {\n      await this.processor.processFile(filePath);\n    } catch (error) {\n      // This might expose file system structure, database details, etc.\n      console.error('Error:', error.message);\n      console.error('Stack:', error.stack);\n    }\n  }\n}\n```\n\n## âš¡ Performance Guidelines\n\n> **Why performance matters**: Users expect responsive applications. Poor performance leads to bad user experience, wasted resources, and can make the application unusable with large datasets.\n\n### Async Best Practices\n\n```typescript\n// âœ… Good: Parallel processing when possible\nexport class EmbeddingGenerator {\n  async processFiles(files: string[]): Promise<EmbeddingVector[]> {\n    // Process files in parallel, but limit concurrency to avoid overwhelming the system\n    const results: EmbeddingVector[] = [];\n    const batchSize = 5; // Process 5 files at a time\n    \n    for (let i = 0; i < files.length; i += batchSize) {\n      const batch = files.slice(i, i + batchSize);\n      const batchPromises = batch.map(file => this.processFile(file));\n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults);\n      \n      // Give other operations a chance to run\n      await this.yield();\n    }\n    \n    return results;\n  }\n  \n  private async yield(): Promise<void> {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n}\n\n// âŒ Bad: Everything in sequence (slow)\nexport class EmbeddingGenerator {\n  async processFiles(files: string[]): Promise<EmbeddingVector[]> {\n    const results: EmbeddingVector[] = [];\n    \n    for (const file of files) {\n      const result = await this.processFile(file); // Processes one at a time\n      results.push(result);\n    }\n    \n    return results;\n  }\n}\n```\n\n### Memory Management\n\n```typescript\n// âœ… Good: Stream processing for large files\nexport class LargeFileProcessor {\n  async processLargeFile(filePath: string): Promise<void> {\n    const stream = fs.createReadStream(filePath, { encoding: 'utf8' });\n    let buffer = '';\n    \n    for await (const chunk of stream) {\n      buffer += chunk;\n      \n      // Process complete lines\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || ''; // Keep incomplete line in buffer\n      \n      for (const line of lines) {\n        await this.processLine(line);\n      }\n    }\n    \n    // Process remaining buffer\n    if (buffer) {\n      await this.processLine(buffer);\n    }\n  }\n}\n\n// âŒ Bad: Loading entire file into memory\nexport class LargeFileProcessor {\n  async processLargeFile(filePath: string): Promise<void> {\n    const content = await fs.readFile(filePath, 'utf8'); // Could be gigabytes!\n    const lines = content.split('\\n');\n    \n    for (const line of lines) {\n      await this.processLine(line);\n    }\n  }\n}\n```\n\n## ğŸ¯ Common Mistakes & How to Avoid Them\n\n### 1. Layer Violations\n\n**Mistake**: Importing infrastructure directly in domain layer\n\n```typescript\n// âŒ Wrong\nimport { CacheService } from '../../infrastructure/cache/storage.js';\n\nexport class FileParser {\n  async parseFile(path: string): Promise<ParsedContent> {\n    const cache = new CacheService(); // Direct dependency!\n    // ...\n  }\n}\n```\n\n**Fix**: Use dependency injection\n\n```typescript\n// âœ… Correct\nexport class FileParser {\n  constructor(\n    private readonly cache: ICacheService // Injected interface\n  ) {}\n  \n  async parseFile(path: string): Promise<ParsedContent> {\n    // Use injected cache\n  }\n}\n```\n\n**Why this matters**: Direct dependencies make code hard to test and tightly coupled to specific implementations.\n\n### 2. God Objects\n\n**Mistake**: Creating classes that do too many things\n\n```typescript\n// âŒ Wrong: This class has too many responsibilities\nexport class FileManager {\n  parseFile(path: string): ParsedContent { /* */ }\n  chunkContent(content: string): TextChunk[] { /* */ }\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n  searchSimilar(query: string): SearchResult[] { /* */ }\n  cacheResults(results: any): void { /* */ }\n  logActivity(message: string): void { /* */ }\n  sendNotifications(event: FileEvent): void { /* */ }\n}\n```\n\n**Fix**: Single Responsibility Principle\n\n```typescript\n// âœ… Correct: Each class has one clear responsibility\nexport class FileParser {\n  parseFile(path: string): ParsedContent { /* */ }\n}\n\nexport class ContentChunker {\n  chunkContent(content: string): TextChunk[] { /* */ }\n}\n\nexport class EmbeddingGenerator {\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n}\n```\n\n**Why this matters**: Smaller, focused classes are easier to understand, test, and modify.\n\n### 3. Poor Error Handling\n\n**Mistake**: Swallowing errors or not handling them appropriately\n\n```typescript\n// âŒ Wrong: Silent failures\nexport class FileProcessor {\n  async processFile(path: string): Promise<void> {\n    try {\n      const content = await this.parseFile(path);\n      await this.processContent(content);\n    } catch (error) {\n      // Silent failure - error is lost!\n      console.log('Something went wrong');\n    }\n  }\n}\n```\n\n**Fix**: Proper error handling and logging\n\n```typescript\n// âœ… Correct: Proper error handling\nexport class FileProcessor {\n  async processFile(path: string): Promise<ProcessResult> {\n    try {\n      const content = await this.parseFile(path);\n      await this.processContent(content);\n      return { success: true };\n    } catch (error) {\n      this.logger.error('Failed to process file', { path, error });\n      return { \n        success: false, \n        error: `Failed to process ${path}: ${error.message}` \n      };\n    }\n  }\n}\n```\n\n### 4. Weak Type Usage\n\n**Mistake**: Using `any` or weak types\n\n```typescript\n// âŒ Wrong: Loses all type safety\nfunction processData(data: any): any {\n  return data.someProperty.map((item: any) => item.value);\n}\n```\n\n**Fix**: Use proper types\n\n```typescript\n// âœ… Correct: Strong typing\ninterface DataItem {\n  readonly value: string;\n  readonly id: number;\n}\n\ninterface InputData {\n  readonly someProperty: readonly DataItem[];\n}\n\nfunction processData(data: InputData): string[] {\n  return data.someProperty.map(item => item.value);\n}\n```\n\n## ğŸ› ï¸ Environment Setup for New Developers\n\n### Required VS Code Extensions\n\n```json\n{\n  \"recommendations\": [\n    \"ms-vscode.vscode-typescript-next\",\n    \"esbenp.prettier-vscode\",\n    \"ms-vscode.vscode-eslint\",\n    \"bradlc.vscode-tailwindcss\",\n    \"ms-vscode.test-adapter-converter\",\n    \"hbenl.vscode-test-explorer\"\n  ]\n}\n```\n\n### Package Scripts Explained\n\n```bash\n# Development\nnpm run dev          # Start development server with hot reload\nnpm run build        # Compile TypeScript to JavaScript\nnpm run type-check   # Check types without compiling\n\n# Testing\nnpm test            # Run all tests\nnpm run test:unit   # Run only unit tests\nnpm run test:integration # Run integration tests\nnpm run test:arch   # Run architectural boundary tests\nnpm run test:watch  # Run tests in watch mode\n\n# Code Quality\nnpm run lint        # Check code style and quality\nnpm run lint:fix    # Fix auto-fixable linting issues\nnpm run format      # Format code with Prettier\n\n# Utilities\nnpm run clean       # Clean build artifacts\nnpm run deps        # Analyze dependencies for cycles\n```\n\n---\n\n**Maintainer**: Development Team  \n**Review Schedule**: Monthly  \n**Next Review**: July 12, 2025\n",
    "type": "md",
    "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
    "metadata": {
      "type": "md",
      "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
      "size": 43851,
      "lastModified": "2025-06-11T22:54:26.693Z",
      "lines": 1402,
      "encoding": "utf-8"
    }
  },
  "chunks": [
    {
      "content": "# Developer Guidelines\n\n**Project**: folder-mcp  \n**Last Updated**: June 12, 2025  \n**Purpose**: Establish coding standards and module boundary guidelines for maintainable, scalable architecture\n\n## ğŸš€ Quick Start for New Developers\n\n### Prerequisites Checklist\n\nBefore you start coding, ensure you have:\n\n- [ ] **Node.js 18+** installed\n- [ ] **TypeScript** knowledge (basics: types, interfaces, generics)\n- [ ] **Git** configured with your credentials\n- [ ] **VS Code** with recommended extensions installed\n- [ ] **Understanding of Promises/async-await** in JavaScript\n\n### First Day Setup\n\n1. **Clone and Setup**:\n   ```powershell\n   git clone <repository-url>\n   cd folder-mcp\n   npm install\n   npm run build\n   npm test\n   ```\n\n2. **Understand the Project**:\n   - Read `README.md` for project overview\n   - Review `CONFIGURATION.md` for setup options\n   - Run `npm run cli -- --help` to see available commands\n\n3. **Explore the Codebase**:\n   - Start with `src/interfaces/` to understand entry points\n   - Look at `src/domain/` to understand business logic\n   - Check `tests/` to see how features are tested\n\n> **Why this order matters**: Starting with interfaces helps you understand what the system does for users, then diving into domain logic shows you how it works internally. This top-down approach prevents getting lost in implementation details.\n\n## ğŸ—ï¸ Architecture Overview\n\nThe folder-mcp project follows a **layered architecture** pattern with strict module boundaries to ensure separation of concerns, testability, and maintainability.\n\n> **Why layered architecture?** It prevents code from becoming a \"big ball of mud\" where everything depends on everything else. This makes the code easier to understand, test, and modify. Think of it like organizing a house - you don't put the kitchen in the bathroom!\n\n### Layered Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             INTERFACES                  â”‚ â† Entry points (CLI, MCP, API)\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚            APPLICATION                  â”‚ â† Use cases & workflows\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚              DOMAIN                     â”‚ â† Business logic\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚          INFRASTRUCTURE                 â”‚ â† Technical services\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚              SHARED                     â”‚ â† Common utilities & DI\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## ğŸ“ Module Structure\n\n### Directory Organization",
      "startPosition": 0,
      "endPosition": 2512,
      "tokenCount": 415,
      "chunkIndex": 0,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": false,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n```\nsrc/\nâ”œâ”€â”€ interfaces/                 # External interfaces (Entry points)\nâ”‚   â”œâ”€â”€ cli/                   # Command-line interface\nâ”‚   â”œâ”€â”€ mcp/                   # MCP protocol interface\nâ”‚   â””â”€â”€ api/                   # Future REST API\nâ”‚\nâ”œâ”€â”€ application/               # Use cases & business workflows\nâ”‚   â”œâ”€â”€ indexing/             # Indexing orchestration\nâ”‚   â”œâ”€â”€ serving/              # Content serving workflows\nâ”‚   â””â”€â”€ monitoring/           # Watch & monitoring workflows\nâ”‚\nâ”œâ”€â”€ domain/                   # Core business logic\nâ”‚   â”œâ”€â”€ files/               # File system domain\nâ”‚   â”œâ”€â”€ content/             # Content processing domain\nâ”‚   â”œâ”€â”€ embeddings/          # AI/ML domain\nâ”‚   â””â”€â”€ search/              # Search domain\nâ”‚\nâ”œâ”€â”€ infrastructure/          # Technical infrastructure\nâ”‚   â”œâ”€â”€ cache/              # Caching infrastructure\nâ”‚   â”œâ”€â”€ config/             # Configuration infrastructure\nâ”‚   â”œâ”€â”€ logging/            # Logging infrastructure\nâ”‚   â””â”€â”€ errors/             # Error handling infrastructure\nâ”‚\nâ””â”€â”€ shared/                 # Shared foundation\n    â”œâ”€â”€ types/              # Shared type definitions\n    â”œâ”€â”€ utils/              # Shared utilities\n    â””â”€â”€ di/                 # Dependency injection\n```\n\n### Layer Responsibilities\n\n#### ğŸ”Œ **Interfaces Layer** (`src/interfaces/`)\n- **Purpose**: External communication protocols and entry points\n- **Responsibilities**:\n  - Handle user input (CLI commands, MCP requests, API calls)\n  - Transform external requests to internal use cases\n  - Format responses for external consumption\n  - Validate input parameters\n- **Characteristics**: Thin layer that delegates to application services\n\n#### ğŸ¯ **Application Layer** (`src/application/`)\n- **Purpose**: Use case orchestration and business workflows\n- **Responsibilities**:\n  - Coordinate multiple domain services\n  - Implement business workflows\n  - Handle cross-cutting concerns (transactions, logging)\n  - Orchestrate complex operations\n- **Characteristics**: Stateless coordinators\n\n#### ğŸ§  **Domain Layer** (`src/domain/`)\n- **Purpose**: Core business logic and rules\n- **Responsibilities**:\n  - Implement business rules and logic\n  - Define domain entities and value objects\n  - Contain domain-specific algorithms\n  - Enforce business invariants\n- **Characteristics**: Pure business logic, no external dependencies\n\n#### ğŸ”§ **Infrastructure Layer** (`src/infrastructure/`)\n- **Purpose**: Technical implementation details\n- **Responsibilities**:\n  - Database access and caching\n  - External service integration\n  - File system operations\n  - Logging and monitoring\n- **Characteristics**: Technical services with external dependencies\n\n#### ğŸ“š **Shared Layer** (`src/shared/`)\n- **Purpose**: Common utilities and foundational services\n- **Responsibilities**:\n  - Type definitions\n  - Utility functions\n  - Dependency injection setup\n  - Constants and enums\n- **Characteristics**: No business logic, used by all layers\n\n## ğŸš§ Module Boundaries & Dependency Rules\n\n### âœ… Allowed Dependencies",
      "startPosition": 2512,
      "endPosition": 5520,
      "tokenCount": 476,
      "chunkIndex": 1,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n| Layer | Can Import From | Rationale |\n|-------|----------------|-----------|\n| `interfaces/` | `application/`, `shared/` | Entry points orchestrate use cases |\n| `application/` | `domain/`, `shared/` | Use cases coordinate domain logic |\n| `domain/` | `shared/` only | Business logic is pure, no external deps |\n| `infrastructure/` | `shared/` only | Technical services use shared utilities |\n| `shared/` | Internal only | Foundation layer has no external deps |\n\n### âŒ Forbidden Dependencies\n\n- **Domain Isolation**: `domain/` cannot import from `infrastructure/` or `application/`\n- **Infrastructure Isolation**: `infrastructure/` cannot import from `domain/` or `application/`\n- **Application Boundaries**: `application/` cannot import from `infrastructure/` (except via DI)\n- **Shared Foundation**: `shared/` cannot import from any other layer\n- **No Circular Dependencies**: No circular dependencies between any modules\n\n> **Why these restrictions matter**: \n> - **Domain Isolation**: Keeps business logic pure and testable without external dependencies\n> - **Infrastructure Isolation**: Prevents technical details from leaking into business logic\n> - **Application Boundaries**: Ensures use cases remain focused on orchestration, not implementation\n> - **Shared Foundation**: Prevents the foundation from becoming dependent on higher-level concerns\n> - **No Circular Dependencies**: Prevents infinite loops during module loading and makes the code easier to understand\n\n### ğŸ”„ Communication Patterns\n\n#### âœ… Correct Patterns\n\n```typescript\n// âœ… Interface â†’ Application â†’ Domain\n// interfaces/cli/commands/serve.ts\nimport { ServingOrchestrator } from '../../../application/serving/index.js';\n\n// âœ… Application â†’ Domain\n// application/serving/orchestrator.ts\nimport { FileParser } from '../../domain/files/index.js';\nimport { VectorSearch } from '../../domain/search/index.js';\n\n// âœ… Domain â†” Infrastructure via Dependency Injection\n// domain/files/parser.ts\nconstructor(\n  private readonly cacheService: ICacheService,  // Injected\n  private readonly loggingService: ILoggingService  // Injected\n) {}\n```\n\n#### âŒ Anti-Patterns\n\n```typescript\n// âŒ Wrong: Direct infrastructure import in domain\nimport { CacheService } from '../../infrastructure/cache/storage.js';\n\n// âŒ Wrong: Domain importing from application\nimport { IndexingOrchestrator } from '../../application/indexing/orchestrator.js';\n\n// âŒ Wrong: Multiple layer jumps\nimport { FileParser } from '../../../domain/files/parser.js';\n```\n\n## ğŸ“ Coding Standards\n\n### 1. Public API Design\n\nEvery module must expose a clean public API through its `index.ts` file:\n\n```typescript\n// src/domain/files/index.ts\nexport { FileParser } from './parser.js';\nexport { FileWatcher } from './watcher.js';\nexport { createFileFingerprint } from './fingerprint.js';\nexport type { \n  FileOperations, \n  ParsedFile, \n  FileMetadata \n} from './types.js';\n\n// Internal implementation details are not exported\n```\n\n### 2. Interface Segregation",
      "startPosition": 5520,
      "endPosition": 8506,
      "tokenCount": 492,
      "chunkIndex": 2,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "Interface Segregation\n\nDefine focused, specific interfaces rather than large monolithic ones:\n\n```typescript\n// âœ… Good: Focused interface\nexport interface FileOperations {\n  scanFolder(path: string): Promise<string[]>;\n  parseFile(path: string): Promise<ParsedContent>;\n  watchFolder(path: string, callback: FileChangeCallback): Promise<void>;\n}\n\n// âŒ Bad: Monolithic interface\nexport interface FileSystemService {\n  scanFolder(path: string): Promise<string[]>;\n  parseFile(path: string): Promise<ParsedContent>;\n  watchFolder(path: string, callback: FileChangeCallback): Promise<void>;\n  cacheFile(path: string): Promise<void>;\n  logActivity(message: string): void;\n  sendNotification(event: FileEvent): Promise<void>;\n}\n```\n\n### 3. Dependency Injection\n\nUse constructor injection for all dependencies:\n\n> **Why constructor injection?** It makes dependencies explicit and required, prevents hidden dependencies, makes testing easier (you can inject mocks), and follows the \"fail fast\" principle - if a dependency is missing, the object can't be created.\n\n```typescript\n// âœ… Good: Constructor injection\nexport class IndexingOrchestrator {\n  constructor(\n    private readonly fileParser: FileParser,\n    private readonly contentChunker: ContentChunker,\n    private readonly embeddingModel: EmbeddingModel,\n    private readonly cache: ICacheService\n  ) {}\n\nasync indexFolder(folderPath: string): Promise<IndexingResult> {\n    // Implementation uses injected dependencies\n    // Easy to test because dependencies can be mocked\n  }\n}\n\n// âŒ Bad: Direct instantiation\nexport class IndexingOrchestrator {\n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    const fileParser = new FileParser(); // Tight coupling - hard to change\n    const cache = new CacheService(); // Hard to test - always uses real cache\n    // What if FileParser needs dependencies? This approach doesn't scale.\n  }\n}\n```\n\n### 4. Error Handling\n\nImplement consistent error handling patterns:\n\n> **Why consistent error handling matters**: It makes debugging easier, provides better user experience, prevents crashes, and helps maintain system stability. Different layers should handle errors differently based on their responsibilities.\n\n```typescript\n// Domain layer: Throw domain-specific errors\n// Why: Domain errors represent business rule violations\nexport class ContentChunker {\n  chunkText(text: string): TextChunk[] {\n    if (!text.trim()) {\n      throw new EmptyContentError('Cannot chunk empty content');\n    }\n    // Implementation\n  }\n}\n\n// Application layer: Handle and transform errors\n// Why: Application layer knows how to recover from different error types\nexport class IndexingOrchestrator {\n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    try {\n      // Implementation\n    } catch (error) {\n      if (error instanceof EmptyContentError) {\n        // Graceful handling: log warning but continue processing\n        this.logger.warn(`Skipping empty file: ${error.message}`);\n        return { success: true, warnings: [error.message] };\n      }\n      // Unknown errors are wrapped and re-thrown\n      throw new IndexingError(`Failed to index folder: ${error.message}`, error);\n    }\n  }\n}",
      "startPosition": 8485,
      "endPosition": 11693,
      "tokenCount": 481,
      "chunkIndex": 3,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n// Interface layer: Convert errors to user-friendly messages\n// Why: Users shouldn't see technical error details\nexport class CLICommand {\n  async execute(): Promise<void> {\n    try {\n      await this.orchestrator.indexFolder(path);\n      console.log('âœ… Indexing completed successfully');\n    } catch (error) {\n      if (error instanceof IndexingError) {\n        console.error(`âŒ Failed to index folder: ${error.userMessage}`);\n        process.exit(1);\n      }\n      throw error; // Re-throw unexpected errors\n    }\n  }\n}\n```\n\n### 5. Type Safety\n\nUse TypeScript effectively for type safety:\n\n> **Why strong typing matters**: TypeScript catches errors at compile time instead of runtime, makes code self-documenting, improves IDE support with autocomplete and refactoring, and makes large codebases maintainable. Weak typing leads to runtime errors and confusion about what data structures contain.\n\n```typescript\n// âœ… Good: Strong typing\nexport interface IndexingOptions {\n  readonly chunkSize: number;        // Clear: this is a number\n  readonly overlapSize: number;      // Clear: this is a number  \n  readonly fileTypes: readonly string[];     // Clear: array of strings, immutable\n  readonly excludePatterns: readonly string[]; // Clear: array of strings, immutable\n}\n\nexport interface IndexingResult {\n  readonly success: boolean;         // Clear: boolean result\n  readonly filesProcessed: number;   // Clear: count of files\n  readonly warnings: readonly string[];     // Clear: array of warning messages\n  readonly errors: readonly Error[]; // Clear: array of error objects\n}\n\n// âŒ Bad: Weak typing\nexport interface IndexingOptions {\n  [key: string]: any; // Could be anything! No IDE help, no compile-time checks\n}\n\n// âŒ Also bad: Mutable types\nexport interface IndexingResult {\n  success: boolean;\n  warnings: string[]; // Can be modified after creation, leading to bugs\n}\n```\n\n**Additional Type Safety Best Practices**:\n\n```typescript\n// âœ… Use union types for constrained values\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n// Prevents typos: logLevel = 'information' would be a compile error\n\n// âœ… Use branded types for IDs\ntype UserId = string & { readonly brand: unique symbol };\ntype PostId = string & { readonly brand: unique symbol };\n// Prevents mixing up different ID types\n\n// âœ… Use optional vs required properties intentionally\ninterface CreateUserRequest {\n  name: string;           // Required\n  email: string;         // Required\n  avatar?: string;       // Optional\n}\n```\n\n## ğŸ”„ Git Workflow & Collaboration\n\n### Branch Strategy",
      "startPosition": 11693,
      "endPosition": 14256,
      "tokenCount": 459,
      "chunkIndex": 4,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n> **Why we use feature branches**: They allow multiple developers to work on different features simultaneously without conflicts, enable code review before merging, and provide a clear history of what changes were made for each feature.\n\n```bash\n# Create a new feature branch\ngit checkout main\ngit pull origin main\ngit checkout -b feature/add-search-ranking\n\n# Work on your feature with meaningful commits\ngit add .\ngit commit -m \"Add vector similarity scoring algorithm\"\ngit commit -m \"Implement search result ranking logic\"\ngit commit -m \"Add tests for ranking functionality\"\n\n# Push and create pull request\ngit push origin feature/add-search-ranking\n```\n\n### Commit Message Guidelines\n\n> **Why good commit messages matter**: They help other developers (and future you) understand why changes were made, make debugging easier when using `git blame`, and create a clear history of the project's evolution.\n\n**Format**: `<type>(<scope>): <description>`\n\n```bash\n# âœ… Good commit messages\nfeat(search): add semantic similarity ranking\nfix(cli): handle empty input files gracefully  \nrefactor(domain): extract chunking strategy interface\ntest(search): add integration tests for vector search\ndocs(api): update MCP protocol documentation\n\n# âŒ Bad commit messages\nfix stuff\nupdate code\nworking version\nasdf\n```\n\n**Types**:\n- `feat`: New feature\n- `fix`: Bug fix\n- `refactor`: Code restructuring without changing behavior\n- `test`: Adding or updating tests\n- `docs`: Documentation changes\n- `chore`: Build process or auxiliary tool changes\n\n### Code Review Guidelines\n\n> **Why code reviews are essential**: They catch bugs early, share knowledge across the team, ensure code follows our standards, and improve overall code quality. Even senior developers benefit from fresh eyes on their code.\n\n**As a Reviewer**:\n- Focus on logic, architecture, and maintainability\n- Be constructive: suggest solutions, not just problems\n- Ask questions if something is unclear\n- Approve when the code meets our standards\n\n**As an Author**:\n- Keep PRs small and focused (< 400 lines when possible)\n- Write clear PR descriptions explaining what and why\n- Respond to feedback promptly and professionally\n- Don't take feedback personally - it's about the code, not you\n\n```markdown\n# Good PR Description Template\n## What\nBrief description of the changes\n\n## Why  \nExplanation of the problem this solves\n\n## Testing\nHow you tested the changes\n\n## Notes\nAny special considerations for reviewers\n```\n\n## ğŸ§ª Testing Guidelines",
      "startPosition": 14256,
      "endPosition": 16755,
      "tokenCount": 489,
      "chunkIndex": 5,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n> **Why testing is crucial**: Tests catch bugs before users do, enable safe refactoring, document how code should behave, and give confidence when making changes. Without tests, every change is scary because you don't know what might break.\n\n### Testing Pyramid\n\n```\n        /\\\n       /  \\\n      / E2E \\ <- Few, slow, expensive but realistic\n     /______\\\n    /        \\\n   /Integration\\ <- Some, medium speed, test component interaction  \n  /__________\\\n /            \\\n/     Unit      \\ <- Many, fast, cheap, test individual functions\n/______________\\\n```\n\n**Why this distribution?**\n- **Unit tests**: Fast feedback, pinpoint failures, easy to write\n- **Integration tests**: Catch interface problems, test real interactions\n- **E2E tests**: Ensure the whole system works, catch UI/UX issues\n\n### 1. Test Structure\n\nOrganize tests to mirror the module structure:\n\n```\ntests/\nâ”œâ”€â”€ unit/\nâ”‚   â”œâ”€â”€ domain/\nâ”‚   â”‚   â”œâ”€â”€ files/\nâ”‚   â”‚   â”œâ”€â”€ content/\nâ”‚   â”‚   â””â”€â”€ search/\nâ”‚   â”œâ”€â”€ application/\nâ”‚   â””â”€â”€ infrastructure/\nâ”œâ”€â”€ integration/\nâ”œâ”€â”€ architectural/\nâ””â”€â”€ e2e/\n```\n\n### 2. Domain Testing\n\nDomain logic should be easily testable in isolation:\n\n> **Why domain tests are important**: Domain logic contains your business rules - the core value of your application. These tests should be fast, reliable, and test pure logic without external dependencies.\n\n```typescript\n// âœ… Good: Pure domain logic test\ndescribe('ContentChunker', () => {\n  it('should chunk text into specified sizes', () => {\n    // Arrange: Set up test data\n    const chunker = new ContentChunker({ chunkSize: 100, overlapSize: 20 });\n    const longText = 'A'.repeat(250); // 250 characters\n\n// Act: Execute the functionality\n    const result = chunker.chunkText(longText);\n\n// Assert: Verify the results\n    expect(result).toHaveLength(3); // Should create 3 chunks\n    expect(result[0].text).toHaveLength(100);\n    expect(result[1].text).toHaveLength(100);\n    expect(result[2].text).toHaveLength(70); // Remaining text\n\n// Verify overlap\n    const overlap1to2 = result[0].text.slice(-20);\n    const start2 = result[1].text.slice(0, 20);\n    expect(overlap1to2).toBe(start2);\n  });\n\nit('should handle edge cases gracefully', () => {\n    const chunker = new ContentChunker({ chunkSize: 100, overlapSize: 20 });\n\n// Test empty input\n    expect(() => chunker.chunkText('')).toThrow(EmptyContentError);\n\n// Test text shorter than chunk size\n    const shortText = 'Short text';\n    const result = chunker.chunkText(shortText);\n    expect(result).toHaveLength(1);\n    expect(result[0].text).toBe(shortText);\n  });\n});\n```\n\n### 3. Application Testing\n\nApplication layer tests should use mocks for dependencies:\n\n```typescript\n// âœ… Good: Application test with mocks\ndescribe('IndexingOrchestrator', () => {\n  it('should orchestrate complete indexing workflow', async () => {\n    const mockFileParser = createMockFileParser();\n    const mockContentChunker = createMockContentChunker();\n    const mockEmbeddingModel = createMockEmbeddingModel();\n    const mockCache = createMockCache();",
      "startPosition": 16755,
      "endPosition": 19790,
      "tokenCount": 493,
      "chunkIndex": 6,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\nconst orchestrator = new IndexingOrchestrator(\n      mockFileParser,\n      mockContentChunker,\n      mockEmbeddingModel,\n      mockCache\n    );\n\nconst result = await orchestrator.indexFolder('/test/path');\n\nexpect(result.success).toBe(true);\n    expect(mockFileParser.scanFolder).toHaveBeenCalledWith('/test/path');\n    expect(mockCache.storeEmbeddings).toHaveBeenCalled();\n  });\n});\n```\n\n### 4. Architectural Tests\n\nEnforce architectural boundaries with automated tests:\n\n```typescript\n// tests/architectural/boundaries.test.ts\ndescribe('Module Boundaries', () => {\n  it('should not allow domain to import from infrastructure', () => {\n    const domainFiles = glob.sync('src/domain/**/*.ts');\n    domainFiles.forEach(file => {\n      const content = fs.readFileSync(file, 'utf8');\n      expect(content).not.toMatch(/from ['\"]\\.\\.\\/.+\\/infrastructure/);\n      expect(content).not.toMatch(/import.*infrastructure/);\n    });\n  });\n\nit('should not allow circular dependencies', () => {\n    const dependencyGraph = buildDependencyGraph('src/');\n    const cycles = findCycles(dependencyGraph);\n    expect(cycles).toHaveLength(0);\n  });\n});\n```\n\n## ğŸš€ Development Workflow\n\n### 1. Adding New Features\n\nWhen adding new functionality, follow this approach:\n\n1. **Identify the Domain**: Which domain does this feature belong to?\n2. **Design Domain Logic**: Implement pure business logic in the domain layer\n3. **Create Application Workflow**: Orchestrate domain services in application layer\n4. **Add Interface**: Expose functionality through appropriate interface\n5. **Update DI Configuration**: Register new services in dependency injection container\n6. **Write Tests**: Add tests at each layer\n7. **Update Documentation**: Update relevant documentation\n\n### 2. File Organization\n\n#### Module Index Files\n\nEach module should have a well-defined public API:\n\n```typescript\n// src/domain/content/index.ts\n// Public API - what other modules can use\nexport { ContentProcessor } from './processing.js';\nexport { ContentChunker } from './chunking.js';\nexport { extractMetadata } from './metadata.js';\n\n// Type exports\nexport type { \n  ContentOperations,\n  TextChunk,\n  ProcessedContent,\n  ChunkingOptions,\n  ContentMetadata \n} from './types.js';\n\n// Internal implementation details are NOT exported\n// - helpers.ts\n// - validators.ts\n// - constants.ts\n```\n\n#### Internal Organization\n\nWithin each module, organize files by responsibility:\n\n```\nsrc/domain/content/\nâ”œâ”€â”€ index.ts           # Public API\nâ”œâ”€â”€ types.ts           # Type definitions\nâ”œâ”€â”€ processing.ts      # Main business logic\nâ”œâ”€â”€ chunking.ts        # Chunking algorithms\nâ”œâ”€â”€ metadata.ts        # Metadata extraction\nâ”œâ”€â”€ helpers.ts         # Internal utilities (not exported)\nâ”œâ”€â”€ validators.ts      # Internal validation (not exported)\nâ””â”€â”€ constants.ts       # Internal constants (not exported)\n```\n\n### 3. Import Guidelines\n\n#### Use Absolute Imports from Module Root\n\n```typescript\n// âœ… Good: Import from module public API\nimport { ContentProcessor } from '../../domain/content/index.js';\nimport { IndexingOrchestrator } from '../../application/indexing/index.js';\n\n// âŒ Bad: Direct imports from internal files\nimport { ContentProcessor } from '../../domain/content/processing.js';\nimport { chunkText } from '../../domain/content/chunking.js';\n```\n\n#### Organize Imports\n\n```typescript\n// 1. Node.js built-in modules\nimport { promises as fs } from 'fs';\nimport path from 'path';",
      "startPosition": 19790,
      "endPosition": 23218,
      "tokenCount": 494,
      "chunkIndex": 7,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "Node.js built-in modules\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\n// 2. External packages\nimport { EventEmitter } from 'events';\nimport chokidar from 'chokidar';\n\n// 3. Internal modules (same layer)\nimport { FileOperations } from './interfaces.js';\nimport { createFileFingerprint } from './fingerprint.js';\n\n// 4. Shared modules\nimport { ILoggingService } from '../../shared/di/interfaces.js';\nimport { validatePath } from '../../shared/utils/index.js';\n\n// 5. Types (separate section)\nimport type { \n  ParsedContent, \n  FileMetadata, \n  FileChangeCallback \n} from './types.js';\n```\n\n## ğŸ” Code Quality Standards\n\n### 1. Naming Conventions\n\n- **Classes**: PascalCase (`FileParser`, `IndexingOrchestrator`)\n- **Interfaces**: PascalCase with 'I' prefix for service interfaces (`ILoggingService`)\n- **Methods**: camelCase (`parseFile`, `generateEmbeddings`)\n- **Constants**: SCREAMING_SNAKE_CASE (`MAX_CHUNK_SIZE`, `DEFAULT_TIMEOUT`)\n- **Files**: kebab-case (`content-processor.ts`, `file-operations.ts`)\n\n### 2. Documentation\n\n#### Class Documentation\n\n```typescript\n/**\n * Processes file content into structured, searchable chunks.\n * \n * This class implements various chunking strategies to break down\n * large documents into smaller, semantically meaningful pieces\n * that can be efficiently processed by embedding models.\n * \n * @example\n * ```typescript\n * const chunker = new ContentChunker({ \n *   chunkSize: 1000, \n *   overlapSize: 200 \n * });\n * const chunks = chunker.chunkText(documentText);\n * ```\n */\nexport class ContentChunker {\n  /**\n   * Creates a new ContentChunker with the specified options.\n   * \n   * @param options - Configuration for chunking behavior\n   * @param logger - Optional logging service for debugging\n   */\n  constructor(\n    private readonly options: ChunkingOptions,\n    private readonly logger?: ILoggingService\n  ) {}\n}\n```\n\n#### Method Documentation\n\n```typescript\n/**\n * Chunks text content into overlapping segments.\n * \n * @param text - The input text to be chunked\n * @param options - Optional chunking options to override defaults\n * @returns Array of text chunks with metadata\n * @throws {EmptyContentError} When input text is empty or whitespace only\n * @throws {InvalidChunkSizeError} When chunk size is invalid\n */\nchunkText(text: string, options?: Partial<ChunkingOptions>): TextChunk[] {\n  // Implementation\n}\n```\n\n### 3. Performance Considerations\n\n#### Async/Await Best Practices\n\n```typescript\n// âœ… Good: Parallel operations where possible\nexport class IndexingOrchestrator {\n  async indexFiles(filePaths: string[]): Promise<IndexingResult> {\n    // Parse files in parallel\n    const parsePromises = filePaths.map(path => this.fileParser.parseFile(path));\n    const parsedFiles = await Promise.all(parsePromises);\n\n// Process chunks sequentially to control memory usage\n    const allChunks: TextChunk[] = [];\n    for (const file of parsedFiles) {\n      const chunks = await this.contentChunker.chunkContent(file.content);\n      allChunks.push(...chunks);\n    }\n\nreturn { success: true, filesProcessed: filePaths.length };\n  }\n}",
      "startPosition": 23132,
      "endPosition": 26234,
      "tokenCount": 496,
      "chunkIndex": 8,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n// âŒ Bad: Sequential operations when parallel is possible\nexport class IndexingOrchestrator {\n  async indexFiles(filePaths: string[]): Promise<IndexingResult> {\n    const allChunks: TextChunk[] = [];\n\n// Unnecessarily sequential\n    for (const path of filePaths) {\n      const file = await this.fileParser.parseFile(path);\n      const chunks = await this.contentChunker.chunkContent(file.content);\n      allChunks.push(...chunks);\n    }\n\nreturn { success: true, filesProcessed: filePaths.length };\n  }\n}\n```\n\n#### Memory Management\n\n```typescript\n// âœ… Good: Process large datasets in batches\nexport class EmbeddingGenerator {\n  async generateEmbeddings(chunks: TextChunk[]): Promise<EmbeddingVector[]> {\n    const batchSize = this.options.batchSize;\n    const results: EmbeddingVector[] = [];\n\nfor (let i = 0; i < chunks.length; i += batchSize) {\n      const batch = chunks.slice(i, i + batchSize);\n      const batchResults = await this.processEmbeddingBatch(batch);\n      results.push(...batchResults);\n\n// Allow garbage collection between batches\n      if (i % (batchSize * 10) === 0) {\n        await this.yield();\n      }\n    }\n\nreturn results;\n  }\n\nprivate async yield(): Promise<void> {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n}\n```\n\n## ğŸš¨ Common Anti-Patterns to Avoid\n\n### 1. Layer Violations\n\n```typescript\n// âŒ Bad: Domain layer directly using infrastructure\nexport class FileParser {\n  async parseFile(path: string): Promise<ParsedContent> {\n    // Wrong: Direct infrastructure dependency\n    const cache = new CacheService();\n    const cached = await cache.get(path);\n    if (cached) return cached;\n\n// Parse file...\n  }\n}\n\n// âœ… Good: Domain layer using injected abstraction\nexport class FileParser {\n  constructor(\n    private readonly cache: ICacheService\n  ) {}\n\nasync parseFile(path: string): Promise<ParsedContent> {\n    const cached = await this.cache.get(path);\n    if (cached) return cached;\n\n// Parse file...\n  }\n}\n```\n\n### 2. God Objects\n\n```typescript\n// âŒ Bad: Single class doing too much\nexport class FileSystemManager {\n  parseFile(path: string): ParsedContent { /* */ }\n  chunkContent(content: string): TextChunk[] { /* */ }\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n  searchSimilar(query: string): SearchResult[] { /* */ }\n  cacheResults(results: any): void { /* */ }\n  logActivity(message: string): void { /* */ }\n}\n\n// âœ… Good: Single responsibility principle\nexport class FileParser {\n  parseFile(path: string): ParsedContent { /* */ }\n}\n\nexport class ContentChunker {\n  chunkContent(content: string): TextChunk[] { /* */ }\n}\n\nexport class EmbeddingGenerator {\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n}\n```\n\n### 3. Leaky Abstractions\n\n```typescript\n// âŒ Bad: Exposing implementation details\nexport interface FileOperations {\n  parseFile(path: string): Promise<ParsedContent>;\n  getCache(): CacheService; // Leaky abstraction\n  getLogger(): Logger; // Leaky abstraction\n}",
      "startPosition": 26234,
      "endPosition": 29217,
      "tokenCount": 478,
      "chunkIndex": 9,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "Leaky Abstractions\n\n```typescript\n// âŒ Bad: Exposing implementation details\nexport interface FileOperations {\n  parseFile(path: string): Promise<ParsedContent>;\n  getCache(): CacheService; // Leaky abstraction\n  getLogger(): Logger; // Leaky abstraction\n}\n\n// âœ… Good: Clean abstraction\nexport interface FileOperations {\n  parseFile(path: string): Promise<ParsedContent>;\n  clearCache(): Promise<void>; // Behavior, not implementation\n}\n```\n\n## ğŸ“š Resources\n\n### Learning Materials\n\n- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)\n- [Dependency Injection Patterns](https://martinfowler.com/articles/injection.html)\n\n### Tools\n\n- **ESLint**: For code quality and style enforcement\n- **Prettier**: For consistent code formatting\n- **TypeScript**: For type safety and better developer experience\n- **Vitest**: For fast, reliable testing\n- **madge**: For dependency analysis and circular dependency detection\n\n### IDE Configuration\n\n#### VS Code Settings\n\n```json\n{\n  \"typescript.preferences.includePackageJsonAutoImports\": \"off\",\n  \"typescript.suggest.autoImports\": true,\n  \"typescript.preferences.importModuleSpecifier\": \"relative\",\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n```\n\n## ğŸš¨ Debugging & Troubleshooting\n\n### Common Issues for New Developers\n\n> **Why debugging skills matter**: You'll spend more time debugging than writing new code. Learning systematic debugging approaches saves hours of frustration and makes you more effective.\n\n#### Issue 1: Import/Module Not Found Errors\n\n```typescript\n// âŒ Error: Cannot find module '../../../domain/files'\nimport { FileParser } from '../../../domain/files';\n\n// âœ… Fix: Use proper file extensions in Node.js\nimport { FileParser } from '../../../domain/files/index.js';\n\n// âœ… Better: Import from module public API\nimport { FileParser } from '../../../domain/files/index.js';\n```\n\n**Debugging steps**:\n1. Check if the file exists at the path you're importing\n2. Verify the file has the correct export\n3. Ensure you're using `.js` extensions for local imports\n4. Check if there's a public API (index.ts) you should import from instead\n\n#### Issue 2: Circular Dependency Errors\n\n```bash\n# Error message you might see:\nReferenceError: Cannot access 'FileParser' before initialization\n```\n\n**How to fix**:\n1. Use the architectural tests to detect cycles: `npm run test:arch`\n2. Identify the cycle using dependency analysis\n3. Break the cycle by:\n   - Moving shared code to a lower layer\n   - Using dependency injection instead of direct imports\n   - Creating an interface in the shared layer\n\n#### Issue 3: Type Errors After Refactoring\n\n```typescript\n// Error: Property 'chunkText' does not exist on type 'ContentProcessor'\nconst chunks = processor.chunkText(content);\n```",
      "startPosition": 28962,
      "endPosition": 31862,
      "tokenCount": 461,
      "chunkIndex": 10,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n**Debugging approach**:\n1. Check what type `processor` actually is (hover in VS Code)\n2. Look at the interface/class definition\n3. Check if the method was renamed or moved\n4. Update the import if the API changed\n\n### Debugging Strategies\n\n#### 1. Console Debugging (Quick & Simple)\n\n```typescript\nexport class IndexingOrchestrator {\n  async indexFolder(folderPath: string): Promise<IndexingResult> {\n    console.log('ğŸ” Starting indexing for:', folderPath);\n\nconst files = await this.fileParser.scanFolder(folderPath);\n    console.log('ğŸ“ Found files:', files.length);\n\nfor (const file of files) {\n      console.log('ğŸ“„ Processing:', file);\n      const content = await this.fileParser.parseFile(file);\n      console.log('ğŸ“ Content length:', content.text.length);\n      // ... more processing\n    }\n  }\n}\n```\n\n#### 2. Using the Debugger (VS Code)\n\n1. Set breakpoints by clicking the left margin in VS Code\n2. Run with debugger: `F5` or `Debug > Start Debugging`\n3. Step through code: `F10` (step over), `F11` (step into)\n4. Inspect variables in the Debug panel\n\n#### 3. Logging for Production\n\n```typescript\nexport class IndexingOrchestrator {\n  constructor(\n    private readonly logger: ILoggingService\n  ) {}\n\nasync indexFolder(folderPath: string): Promise<IndexingResult> {\n    this.logger.info('Starting indexing', { folderPath });\n\ntry {\n      const result = await this.processFolder(folderPath);\n      this.logger.info('Indexing completed', { \n        folderPath, \n        filesProcessed: result.filesProcessed \n      });\n      return result;\n    } catch (error) {\n      this.logger.error('Indexing failed', { folderPath, error });\n      throw error;\n    }\n  }\n}\n```\n\n## ğŸ”’ Security Guidelines\n\n> **Why security matters**: Even internal tools can be attacked or misused. Security vulnerabilities can lead to data breaches, system compromise, or service disruption. Better to build security in from the start than add it later.\n\n### Input Validation\n\n```typescript\n// âœ… Good: Validate all inputs\nexport class FileParser {\n  async parseFile(filePath: string): Promise<ParsedContent> {\n    // Validate input\n    if (!filePath || typeof filePath !== 'string') {\n      throw new ValidationError('File path must be a non-empty string');\n    }\n\n// Prevent path traversal attacks\n    const normalizedPath = path.normalize(filePath);\n    if (normalizedPath.includes('..')) {\n      throw new SecurityError('Path traversal not allowed');\n    }\n\n// Check file exists and is readable\n    await fs.access(normalizedPath, fs.constants.R_OK);\n\n// Proceed with parsing...\n  }\n}\n\n// âŒ Bad: No validation\nexport class FileParser {\n  async parseFile(filePath: string): Promise<ParsedContent> {\n    // Directly using user input - dangerous!\n    const content = await fs.readFile(filePath, 'utf8');\n    return { text: content };\n  }\n}\n```\n\n### Error Information Disclosure",
      "startPosition": 31862,
      "endPosition": 34720,
      "tokenCount": 461,
      "chunkIndex": 11,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "const content = await fs.readFile(filePath, 'utf8');\n    return { text: content };\n  }\n}\n```\n\n### Error Information Disclosure\n\n```typescript\n// âœ… Good: Generic error messages for users\nexport class CLICommand {\n  async execute(filePath: string): Promise<void> {\n    try {\n      await this.processor.processFile(filePath);\n    } catch (error) {\n      // Log full error details for developers\n      this.logger.error('File processing failed', { filePath, error });\n\n// Show generic message to users\n      console.error('Failed to process file. Please check the file path and permissions.');\n      process.exit(1);\n    }\n  }\n}\n\n// âŒ Bad: Exposing internal details\nexport class CLICommand {\n  async execute(filePath: string): Promise<void> {\n    try {\n      await this.processor.processFile(filePath);\n    } catch (error) {\n      // This might expose file system structure, database details, etc.\n      console.error('Error:', error.message);\n      console.error('Stack:', error.stack);\n    }\n  }\n}\n```\n\n## âš¡ Performance Guidelines\n\n> **Why performance matters**: Users expect responsive applications. Poor performance leads to bad user experience, wasted resources, and can make the application unusable with large datasets.\n\n### Async Best Practices\n\n```typescript\n// âœ… Good: Parallel processing when possible\nexport class EmbeddingGenerator {\n  async processFiles(files: string[]): Promise<EmbeddingVector[]> {\n    // Process files in parallel, but limit concurrency to avoid overwhelming the system\n    const results: EmbeddingVector[] = [];\n    const batchSize = 5; // Process 5 files at a time\n\nfor (let i = 0; i < files.length; i += batchSize) {\n      const batch = files.slice(i, i + batchSize);\n      const batchPromises = batch.map(file => this.processFile(file));\n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults);\n\n// Give other operations a chance to run\n      await this.yield();\n    }\n\nreturn results;\n  }\n\nprivate async yield(): Promise<void> {\n    return new Promise(resolve => setImmediate(resolve));\n  }\n}\n\n// âŒ Bad: Everything in sequence (slow)\nexport class EmbeddingGenerator {\n  async processFiles(files: string[]): Promise<EmbeddingVector[]> {\n    const results: EmbeddingVector[] = [];\n\nfor (const file of files) {\n      const result = await this.processFile(file); // Processes one at a time\n      results.push(result);\n    }\n\nreturn results;\n  }\n}\n```\n\n### Memory Management\n\n```typescript\n// âœ… Good: Stream processing for large files\nexport class LargeFileProcessor {\n  async processLargeFile(filePath: string): Promise<void> {\n    const stream = fs.createReadStream(filePath, { encoding: 'utf8' });\n    let buffer = '';\n\nfor await (const chunk of stream) {\n      buffer += chunk;\n\n// Process complete lines\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\nfor (const line of lines) {\n        await this.processLine(line);\n      }\n    }",
      "startPosition": 34594,
      "endPosition": 37562,
      "tokenCount": 487,
      "chunkIndex": 12,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "\n\n// Process remaining buffer\n    if (buffer) {\n      await this.processLine(buffer);\n    }\n  }\n}\n\n// âŒ Bad: Loading entire file into memory\nexport class LargeFileProcessor {\n  async processLargeFile(filePath: string): Promise<void> {\n    const content = await fs.readFile(filePath, 'utf8'); // Could be gigabytes!\n    const lines = content.split('\\n');\n\nfor (const line of lines) {\n      await this.processLine(line);\n    }\n  }\n}\n```\n\n## ğŸ¯ Common Mistakes & How to Avoid Them\n\n### 1. Layer Violations\n\n**Mistake**: Importing infrastructure directly in domain layer\n\n```typescript\n// âŒ Wrong\nimport { CacheService } from '../../infrastructure/cache/storage.js';\n\nexport class FileParser {\n  async parseFile(path: string): Promise<ParsedContent> {\n    const cache = new CacheService(); // Direct dependency!\n    // ...\n  }\n}\n```\n\n**Fix**: Use dependency injection\n\n```typescript\n// âœ… Correct\nexport class FileParser {\n  constructor(\n    private readonly cache: ICacheService // Injected interface\n  ) {}\n\nasync parseFile(path: string): Promise<ParsedContent> {\n    // Use injected cache\n  }\n}\n```\n\n**Why this matters**: Direct dependencies make code hard to test and tightly coupled to specific implementations.\n\n### 2. God Objects\n\n**Mistake**: Creating classes that do too many things\n\n```typescript\n// âŒ Wrong: This class has too many responsibilities\nexport class FileManager {\n  parseFile(path: string): ParsedContent { /* */ }\n  chunkContent(content: string): TextChunk[] { /* */ }\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n  searchSimilar(query: string): SearchResult[] { /* */ }\n  cacheResults(results: any): void { /* */ }\n  logActivity(message: string): void { /* */ }\n  sendNotifications(event: FileEvent): void { /* */ }\n}\n```\n\n**Fix**: Single Responsibility Principle\n\n```typescript\n// âœ… Correct: Each class has one clear responsibility\nexport class FileParser {\n  parseFile(path: string): ParsedContent { /* */ }\n}\n\nexport class ContentChunker {\n  chunkContent(content: string): TextChunk[] { /* */ }\n}\n\nexport class EmbeddingGenerator {\n  generateEmbeddings(chunks: TextChunk[]): EmbeddingVector[] { /* */ }\n}\n```\n\n**Why this matters**: Smaller, focused classes are easier to understand, test, and modify.\n\n### 3. Poor Error Handling\n\n**Mistake**: Swallowing errors or not handling them appropriately\n\n```typescript\n// âŒ Wrong: Silent failures\nexport class FileProcessor {\n  async processFile(path: string): Promise<void> {\n    try {\n      const content = await this.parseFile(path);\n      await this.processContent(content);\n    } catch (error) {\n      // Silent failure - error is lost!\n      console.log('Something went wrong');\n    }\n  }\n}\n```\n\n**Fix**: Proper error handling and logging",
      "startPosition": 37562,
      "endPosition": 40297,
      "tokenCount": 467,
      "chunkIndex": 13,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    },
    {
      "content": "console.log('Something went wrong');\n    }\n  }\n}\n```\n\n**Fix**: Proper error handling and logging\n\n```typescript\n// âœ… Correct: Proper error handling\nexport class FileProcessor {\n  async processFile(path: string): Promise<ProcessResult> {\n    try {\n      const content = await this.parseFile(path);\n      await this.processContent(content);\n      return { success: true };\n    } catch (error) {\n      this.logger.error('Failed to process file', { path, error });\n      return { \n        success: false, \n        error: `Failed to process ${path}: ${error.message}` \n      };\n    }\n  }\n}\n```\n\n### 4. Weak Type Usage\n\n**Mistake**: Using `any` or weak types\n\n```typescript\n// âŒ Wrong: Loses all type safety\nfunction processData(data: any): any {\n  return data.someProperty.map((item: any) => item.value);\n}\n```\n\n**Fix**: Use proper types\n\n```typescript\n// âœ… Correct: Strong typing\ninterface DataItem {\n  readonly value: string;\n  readonly id: number;\n}\n\ninterface InputData {\n  readonly someProperty: readonly DataItem[];\n}\n\nfunction processData(data: InputData): string[] {\n  return data.someProperty.map(item => item.value);\n}\n```\n\n## ğŸ› ï¸ Environment Setup for New Developers\n\n### Required VS Code Extensions\n\n```json\n{\n  \"recommendations\": [\n    \"ms-vscode.vscode-typescript-next\",\n    \"esbenp.prettier-vscode\",\n    \"ms-vscode.vscode-eslint\",\n    \"bradlc.vscode-tailwindcss\",\n    \"ms-vscode.test-adapter-converter\",\n    \"hbenl.vscode-test-explorer\"\n  ]\n}\n```\n\n### Package Scripts Explained\n\n```bash\n# Development\nnpm run dev          # Start development server with hot reload\nnpm run build        # Compile TypeScript to JavaScript\nnpm run type-check   # Check types without compiling\n\n# Testing\nnpm test            # Run all tests\nnpm run test:unit   # Run only unit tests\nnpm run test:integration # Run integration tests\nnpm run test:arch   # Run architectural boundary tests\nnpm run test:watch  # Run tests in watch mode\n\n# Code Quality\nnpm run lint        # Check code style and quality\nnpm run lint:fix    # Fix auto-fixable linting issues\nnpm run format      # Format code with Prettier\n\n# Utilities\nnpm run clean       # Clean build artifacts\nnpm run deps        # Analyze dependencies for cycles\n```\n\n---\n\n**Maintainer**: Development Team  \n**Review Schedule**: Monthly  \n**Next Review**: July 12, 2025",
      "startPosition": 40201,
      "endPosition": 42510,
      "tokenCount": 385,
      "chunkIndex": 14,
      "metadata": {
        "sourceFile": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
        "sourceType": "md",
        "totalChunks": 15,
        "hasOverlap": true,
        "originalMetadata": {
          "type": "md",
          "originalPath": "docs\\Legacy\\DEVELOPER_GUIDELINES.md",
          "size": 43851,
          "lastModified": "2025-06-11T22:54:26.693Z",
          "lines": 1402,
          "encoding": "utf-8"
        }
      }
    }
  ],
  "processedAt": "2025-06-18T20:41:34.837Z"
}